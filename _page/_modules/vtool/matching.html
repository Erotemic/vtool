

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>vtool.matching &mdash; vtool 1.0.1.dev1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="vtool 1.0.1.dev1 documentation" href="../../index.html"/>
        <link rel="up" title="vtool" href="../vtool.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> vtool
          

          
          </a>

          
            
            
              <div class="version">
                1.0.1.dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../vtool.html">vtool package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">vtool</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../vtool.html">vtool</a> &raquo;</li>
      
    <li>vtool.matching</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for vtool.matching</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="c">#from six.moves import range</span>
<span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">vtool</span> <span class="kn">import</span> <span class="n">keypoint</span> <span class="k">as</span> <span class="n">ktool</span>
<span class="p">(</span><span class="k">print</span><span class="p">,</span> <span class="n">print_</span><span class="p">,</span> <span class="n">printDBG</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&#39;[matching]&#39;</span><span class="p">,</span> <span class="n">DEBUG</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>


<span class="c"># maximum SIFT matching distance based using uint8 trick from hesaff</span>
<span class="n">PSEUDO_MAX_VEC_COMPONENT</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">PSEUDO_MAX_DIST_SQRD</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">PSEUDO_MAX_VEC_COMPONENT</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">PSEUDO_MAX_DIST</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">PSEUDO_MAX_VEC_COMPONENT</span><span class="p">)</span>


<div class="viewcode-block" id="show_matching_dict"><a class="viewcode-back" href="../../vtool.html#vtool.matching.show_matching_dict">[docs]</a><span class="k">def</span> <span class="nf">show_matching_dict</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">plottool.interact_matches</span>
    <span class="c">#import plottool as pt</span>
    <span class="n">fm</span><span class="p">,</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="s">&#39;RAT+SV&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">H1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;H_RAT&#39;</span><span class="p">]</span>
    <span class="c">#fm, fs = matches[&#39;RAT&#39;][0:2]</span>
    <span class="n">rchip1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip1&#39;</span><span class="p">]</span>
    <span class="n">rchip2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip2&#39;</span><span class="p">]</span>
    <span class="n">kpts1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;kpts1&#39;</span><span class="p">]</span>
    <span class="n">kpts2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;kpts2&#39;</span><span class="p">]</span>

    <span class="n">vecs1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;vecs1&#39;</span><span class="p">]</span>
    <span class="n">vecs2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;vecs2&#39;</span><span class="p">]</span>

    <span class="c">#pt.show_chipmatch2(rchip1, rchip2, kpts1, kpts2, fm=fm, fs=fs)</span>

    <span class="n">vecs1</span><span class="p">,</span> <span class="n">vecs2</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;vecs1&#39;</span><span class="p">,</span> <span class="s">&#39;vecs2&#39;</span><span class="p">])</span>
    <span class="n">fsv</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">interact</span> <span class="o">=</span> <span class="n">plottool</span><span class="o">.</span><span class="n">interact_matches</span><span class="o">.</span><span class="n">MatchInteraction2</span><span class="p">(</span>
        <span class="n">rchip1</span><span class="p">,</span> <span class="n">rchip2</span><span class="p">,</span> <span class="n">kpts1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">fm</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fsv</span><span class="p">,</span> <span class="n">vecs1</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">H1</span><span class="o">=</span><span class="n">H1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">interact</span><span class="o">.</span><span class="n">show_page</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">interact</span>
    <span class="c">#MatchInteraction2</span>

</div>
<div class="viewcode-block" id="vsone_image_fpath_matching"><a class="viewcode-back" href="../../vtool.html#vtool.matching.vsone_image_fpath_matching">[docs]</a><span class="k">def</span> <span class="nf">vsone_image_fpath_matching</span><span class="p">(</span><span class="n">rchip_fpath1</span><span class="p">,</span> <span class="n">rchip_fpath2</span><span class="p">,</span> <span class="n">cfgdict</span><span class="o">=</span><span class="p">{},</span> <span class="n">metadata_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        rchip_fpath1 (str):</span>
<span class="sd">        rchip_fpath2 (str):</span>
<span class="sd">        cfgdict (dict): (default = {})</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m vtool --tf vsone_image_fpath_matching --show</span>
<span class="sd">        python -m vtool --tf vsone_image_fpath_matching --show --helpx</span>
<span class="sd">        python -m vtool --tf vsone_image_fpath_matching --show --feat-type=hesaff+siam128</span>
<span class="sd">        python -m vtool --tf vsone_image_fpath_matching --show --feat-type=hesaff+siam128 --ratio-thresh=.9</span>
<span class="sd">        python -m vtool --tf vsone_image_fpath_matching --show --feat-type=hesaff+sift --ratio-thresh=.8</span>
<span class="sd">        python -m vtool --tf vsone_image_fpath_matching --show --feat-type=hesaff+sift --ratio-thresh=.8</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from vtool.matching import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import vtool as vt</span>
<span class="sd">        &gt;&gt;&gt; rchip_fpath1 = ut.grab_test_imgpath(&#39;easy1.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; rchip_fpath2 = ut.grab_test_imgpath(&#39;easy2.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; import pyhesaff</span>
<span class="sd">        &gt;&gt;&gt; metadata_ = None</span>
<span class="sd">        &gt;&gt;&gt; default_cfgdict = dict(feat_type=&#39;hesaff+sift&#39;, ratio_thresh=.625,</span>
<span class="sd">        &gt;&gt;&gt;                        **pyhesaff.get_hesaff_default_params())</span>
<span class="sd">        &gt;&gt;&gt; cfgdict = ut.parse_dict_from_argv(default_cfgdict)</span>
<span class="sd">        &gt;&gt;&gt; matches, metadata = vsone_image_fpath_matching(rchip_fpath1,</span>
<span class="sd">        &gt;&gt;&gt;                                                rchip_fpath2, cfgdict)</span>
<span class="sd">        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">        &gt;&gt;&gt; show_matching_dict(matches, metadata, mode=1)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">LazyDict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">metadata_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metadata_</span><span class="p">)</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip_fpath1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rchip_fpath1</span>
    <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip_fpath2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rchip_fpath2</span>
    <span class="n">matches</span><span class="p">,</span> <span class="n">metdata</span> <span class="o">=</span>  <span class="n">vsone_matching</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">cfgdict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span><span class="p">,</span> <span class="n">metdata</span>

</div>
<div class="viewcode-block" id="vsone_matching"><a class="viewcode-back" href="../../vtool.html#vtool.matching.vsone_matching">[docs]</a><span class="k">def</span> <span class="nf">vsone_matching</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">cfgdict</span><span class="o">=</span><span class="p">{},</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metadata is a dictionary that contains either computed information</span>
<span class="sd">    necessary for matching or the dependenceis of those computations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">vtool</span> <span class="kn">as</span> <span class="nn">vt</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">LazyDict</span><span class="p">),</span> <span class="s">&#39;type(metadata)=</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">metadata</span><span class="p">),)</span>

    <span class="k">if</span> <span class="s">&#39;rchip1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">eval_rchip1</span><span class="p">():</span>
            <span class="n">rchip_fpath1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip_fpath1&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">vt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">rchip_fpath1</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;rchip1&#39;</span><span class="p">,</span> <span class="n">eval_rchip1</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;rchip2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">eval_rchip2</span><span class="p">():</span>
            <span class="n">rchip_fpath2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip_fpath2&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">vt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">rchip_fpath2</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;rchip2&#39;</span><span class="p">,</span> <span class="n">eval_rchip2</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;dlen_sqrd2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">eval_dlen_sqrd2</span><span class="p">():</span>
            <span class="n">rchip2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip2&#39;</span><span class="p">]</span>
            <span class="n">dlen_sqrd2</span> <span class="o">=</span> <span class="n">rchip2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rchip2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">dlen_sqrd2</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;dlen_sqrd2&#39;</span><span class="p">,</span> <span class="n">eval_dlen_sqrd2</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;kpts1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span> <span class="ow">or</span> <span class="s">&#39;vecs1&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">eval_feats1</span><span class="p">():</span>
            <span class="n">rchip1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip1&#39;</span><span class="p">]</span>
            <span class="n">_feats1</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">extract_features</span><span class="p">(</span><span class="n">rchip1</span><span class="p">,</span> <span class="o">**</span><span class="n">cfgdict</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_feats1</span>

        <span class="k">def</span> <span class="nf">eval_kpts1</span><span class="p">():</span>
            <span class="n">_feats1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;_feats1&#39;</span><span class="p">]</span>
            <span class="n">kpts1</span> <span class="o">=</span> <span class="n">_feats1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">kpts1</span>

        <span class="k">def</span> <span class="nf">eval_vecs1</span><span class="p">():</span>
            <span class="n">_feats1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;_feats1&#39;</span><span class="p">]</span>
            <span class="n">vecs1</span> <span class="o">=</span> <span class="n">_feats1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">vecs1</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;_feats1&#39;</span><span class="p">,</span> <span class="n">eval_feats1</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;kpts1&#39;</span><span class="p">,</span> <span class="n">eval_kpts1</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;vecs1&#39;</span><span class="p">,</span> <span class="n">eval_vecs1</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">&#39;kpts2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span> <span class="ow">or</span> <span class="s">&#39;vecs2&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">eval_feats2</span><span class="p">():</span>
            <span class="n">rchip2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;rchip2&#39;</span><span class="p">]</span>
            <span class="n">_feats2</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">extract_features</span><span class="p">(</span><span class="n">rchip2</span><span class="p">,</span> <span class="o">**</span><span class="n">cfgdict</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_feats2</span>

        <span class="k">def</span> <span class="nf">eval_kpts2</span><span class="p">():</span>
            <span class="n">_feats2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;_feats2&#39;</span><span class="p">]</span>
            <span class="n">kpts2</span> <span class="o">=</span> <span class="n">_feats2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">kpts2</span>

        <span class="k">def</span> <span class="nf">eval_vecs2</span><span class="p">():</span>
            <span class="n">_feats2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;_feats2&#39;</span><span class="p">]</span>
            <span class="n">vecs2</span> <span class="o">=</span> <span class="n">_feats2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">vecs2</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;_feats2&#39;</span><span class="p">,</span> <span class="n">eval_feats2</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;kpts2&#39;</span><span class="p">,</span> <span class="n">eval_kpts2</span><span class="p">)</span>
        <span class="n">metadata</span><span class="o">.</span><span class="n">set_lazy_func</span><span class="p">(</span><span class="s">&#39;vecs2&#39;</span><span class="p">,</span> <span class="n">eval_vecs2</span><span class="p">)</span>

    <span class="c"># Exceute relevant dependencies</span>
    <span class="n">kpts1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;kpts1&#39;</span><span class="p">]</span>
    <span class="n">vecs1</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;vecs1&#39;</span><span class="p">]</span>
    <span class="n">kpts2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;kpts2&#39;</span><span class="p">]</span>
    <span class="n">vecs2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;vecs2&#39;</span><span class="p">]</span>
    <span class="n">dlen_sqrd2</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;dlen_sqrd2&#39;</span><span class="p">]</span>

    <span class="n">matches</span><span class="p">,</span> <span class="n">output_metdata</span> <span class="o">=</span> <span class="n">vsone_feature_matching</span><span class="p">(</span>
        <span class="n">kpts1</span><span class="p">,</span> <span class="n">vecs1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">dlen_sqrd2</span><span class="p">,</span> <span class="n">cfgdict</span><span class="o">=</span><span class="n">cfgdict</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">output_metdata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matches</span><span class="p">,</span> <span class="n">metadata</span>

</div>
<div class="viewcode-block" id="vsone_feature_matching"><a class="viewcode-back" href="../../vtool.html#vtool.matching.vsone_feature_matching">[docs]</a><span class="k">def</span> <span class="nf">vsone_feature_matching</span><span class="p">(</span><span class="n">kpts1</span><span class="p">,</span> <span class="n">vecs1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">dlen_sqrd2</span><span class="p">,</span> <span class="n">cfgdict</span><span class="o">=</span><span class="p">{},</span>
                           <span class="n">verbose</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Actual logic for matching</span>
<span class="sd">    Args:</span>
<span class="sd">        vecs1 (ndarray[uint8_t, ndim=2]): SIFT descriptors</span>
<span class="sd">        vecs2 (ndarray[uint8_t, ndim=2]): SIFT descriptors</span>
<span class="sd">        kpts1 (ndarray[float32_t, ndim=2]):  keypoints</span>
<span class="sd">        kpts2 (ndarray[float32_t, ndim=2]):  keypoints</span>

<span class="sd">    Ignore:</span>
<span class="sd">        %pylab qt4</span>
<span class="sd">        import plottool as pt</span>
<span class="sd">        pt.imshow(rchip1)</span>
<span class="sd">        pt.draw_kpts2(kpts1)</span>

<span class="sd">        pt.show_chipmatch2(rchip1, rchip2, kpts1, kpts2, fm=fm, fs=fs)</span>
<span class="sd">        pt.show_chipmatch2(rchip1, rchip2, kpts1, kpts2, fm=fm, fs=fs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">vtool</span> <span class="kn">as</span> <span class="nn">vt</span>
    <span class="kn">import</span> <span class="nn">pyflann</span>
    <span class="kn">from</span> <span class="nn">vtool</span> <span class="kn">import</span> <span class="n">spatial_verification</span> <span class="k">as</span> <span class="n">sver</span>
    <span class="c">#import vtool as vt</span>
    <span class="n">sver_xy_thresh</span> <span class="o">=</span> <span class="n">cfgdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;sver_xy_thresh&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mo">01</span><span class="p">)</span>
    <span class="n">ratio_thresh</span> <span class="o">=</span>  <span class="n">cfgdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;ratio_thresh&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">625</span><span class="p">)</span>
    <span class="n">refine_method</span> <span class="o">=</span>  <span class="n">cfgdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;refine_method&#39;</span><span class="p">,</span> <span class="s">&#39;homog&#39;</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span>  <span class="n">cfgdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Knorm</span> <span class="o">=</span>  <span class="n">cfgdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Knorm&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c">#ratio_thresh =  .99</span>
    <span class="c"># GET NEAREST NEIGHBORS</span>
    <span class="n">checks</span> <span class="o">=</span> <span class="mi">800</span>
    <span class="n">flann_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;algorithm&#39;</span><span class="p">:</span> <span class="s">&#39;kdtree&#39;</span><span class="p">,</span>
        <span class="s">&#39;trees&#39;</span><span class="p">:</span> <span class="mi">8</span>
    <span class="p">}</span>
    <span class="c">#pseudo_max_dist_sqrd = (np.sqrt(2) * 512) ** 2</span>
    <span class="c">#pseudo_max_dist_sqrd = 2 * (512 ** 2)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">flann</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">flann_cache</span><span class="p">(</span><span class="n">vecs1</span><span class="p">,</span> <span class="n">flann_params</span><span class="o">=</span><span class="n">flann_params</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">K</span> <span class="o">+</span> <span class="n">Knorm</span>
        <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span> <span class="o">=</span> <span class="n">normalized_nearest_neighbors</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">,</span> <span class="n">checks</span><span class="p">)</span>
        <span class="c">#fx2_to_fx1, _fx2_to_dist = flann.nn_index(vecs2, num_neighbors=K, checks=checks)</span>
    <span class="k">except</span> <span class="n">pyflann</span><span class="o">.</span><span class="n">FLANNException</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;vecs1.shape = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vecs1</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;vecs2.shape = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vecs2</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;vecs1.dtype = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vecs1</span><span class="o">.</span><span class="n">dtype</span><span class="p">,))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;vecs2.dtype = </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vecs2</span><span class="o">.</span><span class="n">dtype</span><span class="p">,))</span>
        <span class="k">raise</span>
    <span class="n">assigntup</span> <span class="o">=</span> <span class="n">assign_unconstrained_matches</span><span class="p">(</span><span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span><span class="p">)</span>
    <span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span> <span class="o">=</span> <span class="n">assigntup</span>
    <span class="n">fm_ORIG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx2_match</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">fs_ORIG</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span><span class="p">)</span>
    <span class="c"># APPLY RATIO TEST</span>
    <span class="n">fm_RAT</span><span class="p">,</span> <span class="n">fs_RAT</span><span class="p">,</span> <span class="n">fm_norm_RAT</span> <span class="o">=</span> <span class="n">ratio_test</span><span class="p">(</span><span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span>
                                             <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span><span class="p">,</span>
                                             <span class="n">ratio_thresh</span><span class="p">)</span>
    <span class="c"># SPATIAL VERIFICATION FILTER</span>
    <span class="c">#with ut.EmbedOnException():</span>
    <span class="n">match_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fm_RAT</span><span class="p">))</span>
    <span class="n">svtup</span> <span class="o">=</span> <span class="n">sver</span><span class="o">.</span><span class="n">spatially_verify_kpts</span><span class="p">(</span><span class="n">kpts1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">fm_RAT</span><span class="p">,</span> <span class="n">sver_xy_thresh</span><span class="p">,</span>
                                       <span class="n">dlen_sqrd2</span><span class="p">,</span> <span class="n">match_weights</span><span class="o">=</span><span class="n">match_weights</span><span class="p">,</span>
                                       <span class="n">refine_method</span><span class="o">=</span><span class="n">refine_method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">svtup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="p">(</span><span class="n">homog_inliers</span><span class="p">,</span> <span class="n">homog_errors</span><span class="p">,</span> <span class="n">H_RAT</span><span class="p">)</span> <span class="o">=</span> <span class="n">svtup</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H_RAT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">homog_inliers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fm_SV</span> <span class="o">=</span> <span class="n">fm_RAT</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">homog_inliers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fs_SV</span> <span class="o">=</span> <span class="n">fs_RAT</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">homog_inliers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fm_norm_SV</span> <span class="o">=</span> <span class="n">fm_norm_RAT</span><span class="p">[</span><span class="n">homog_inliers</span><span class="p">]</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;ORIG&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">fm_ORIG</span><span class="p">,</span> <span class="n">fs_ORIG</span><span class="p">),</span>
        <span class="s">&#39;RAT&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">fm_RAT</span><span class="p">,</span> <span class="n">fs_RAT</span><span class="p">,</span> <span class="n">fm_norm_RAT</span><span class="p">),</span>
        <span class="s">&#39;RAT+SV&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">fm_SV</span><span class="p">,</span> <span class="n">fs_SV</span><span class="p">,</span> <span class="n">fm_norm_SV</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="n">output_metdata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;H_RAT&#39;</span><span class="p">:</span> <span class="n">H_RAT</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">matches</span><span class="p">,</span> <span class="n">output_metdata</span>

</div>
<div class="viewcode-block" id="normalized_nearest_neighbors"><a class="viewcode-back" href="../../vtool.html#vtool.matching.normalized_nearest_neighbors">[docs]</a><span class="k">def</span> <span class="nf">normalized_nearest_neighbors</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="mi">800</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    uses flann index to return nearest neighbors with distances normalized</span>
<span class="sd">    between 0 and 1 using sifts uint8 trick</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">_fx2_to_dist</span> <span class="o">=</span> <span class="n">flann</span><span class="o">.</span><span class="n">nn_index</span><span class="p">(</span><span class="n">vecs2</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="n">checks</span><span class="p">)</span>
    <span class="n">fx2_to_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_fx2_to_dist</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)),</span>
                            <span class="n">PSEUDO_MAX_DIST</span><span class="p">)</span>  <span class="c"># normalized dist</span>
    <span class="c">#fx2_to_dist = np.divide(_fx2_to_dist.astype(np.float64),</span>
    <span class="c">#PSEUDO_MAX_DIST_SQRD)  # squared normalized dist</span>
    <span class="k">return</span> <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span>

</div>
<div class="viewcode-block" id="assign_spatially_constrained_matches"><a class="viewcode-back" href="../../vtool.html#vtool.matching.assign_spatially_constrained_matches">[docs]</a><span class="k">def</span> <span class="nf">assign_spatially_constrained_matches</span><span class="p">(</span><span class="n">chip2_dlen_sqrd</span><span class="p">,</span> <span class="n">kpts1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span>
                                         <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span><span class="p">,</span> <span class="n">match_xy_thresh</span><span class="p">,</span>
                                         <span class="n">norm_xy_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        chip2_dlen_sqrd (dict):</span>
<span class="sd">        kpts1 (ndarray[float32_t, ndim=2]):  keypoints</span>
<span class="sd">        kpts2 (ndarray[float32_t, ndim=2]):  keypoints</span>
<span class="sd">        H (ndarray[float64_t, ndim=2]):  homography/perspective matrix that maps image1 space into image2 space</span>
<span class="sd">        fx2_to_fx1 (ndarray): image2s nearest feature indices in image1</span>
<span class="sd">        fx2_to_dist (ndarray):</span>
<span class="sd">        match_xy_thresh (float):</span>
<span class="sd">        norm_xy_bounds (tuple):</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: assigntup(</span>
<span class="sd">            fx2_match, - matching feature indices in image 2</span>
<span class="sd">            fx1_match, - matching feature indices in image 1</span>
<span class="sd">            fx1_norm,  - normmalizing indices in image 1</span>
<span class="sd">            match_dist, - descriptor distances between fx2_match and fx1_match</span>
<span class="sd">            norm_dist, - descriptor distances between fx2_match and fx1_norm</span>
<span class="sd">            )</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m vtool.matching --test-assign_spatially_constrained_matches</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from vtool.matching import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; kpts1 = np.array([[  6.,   4.,   15.84,    4.66,    7.24,    0.  ],</span>
<span class="sd">        ...                   [  9.,   3.,   20.09,    5.76,    6.2 ,    0.  ],</span>
<span class="sd">        ...                   [  1.,   1.,   12.96,    1.73,    8.77,    0.  ],])</span>
<span class="sd">        &gt;&gt;&gt; kpts2 = np.array([[  2.,   1.,   12.11,    0.38,    8.04,    0.  ],</span>
<span class="sd">        ...                   [  5.,   1.,   22.4 ,    1.31,    5.04,    0.  ],</span>
<span class="sd">        ...                   [  6.,   1.,   19.25,    1.74,    4.72,    0.  ],])</span>
<span class="sd">        &gt;&gt;&gt; match_xy_thresh = .37</span>
<span class="sd">        &gt;&gt;&gt; chip2_dlen_sqrd = 1400</span>
<span class="sd">        &gt;&gt;&gt; norm_xy_bounds = (0.0, 1.0)</span>
<span class="sd">        &gt;&gt;&gt; H = np.array([[ 2,  0, 0],</span>
<span class="sd">        &gt;&gt;&gt;               [ 0,  1, 0],</span>
<span class="sd">        &gt;&gt;&gt;               [ 0,  0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; fx2_to_fx1 = np.array([[2, 1, 0],</span>
<span class="sd">        &gt;&gt;&gt;                        [0, 1, 2],</span>
<span class="sd">        &gt;&gt;&gt;                        [2, 0, 1]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; fx2_to_dist = np.array([[.40, .80, .85],</span>
<span class="sd">        &gt;&gt;&gt;                         [.30, .50, .60],</span>
<span class="sd">        &gt;&gt;&gt;                         [.80, .90, .91]], dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; assigntup = assign_spatially_constrained_matches(chip2_dlen_sqrd, kpts1, kpts2, H, fx2_to_fx1, fx2_to_dist, match_xy_thresh, norm_xy_bounds)</span>
<span class="sd">        &gt;&gt;&gt; fx2_match, fx1_match, fx1_norm, match_dist, norm_dist = assigntup</span>
<span class="sd">        &gt;&gt;&gt; result = ut.list_str(assigntup, precision=3)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (</span>
<span class="sd">            np.array([0, 1, 2], dtype=np.int32),</span>
<span class="sd">            np.array([2, 0, 2], dtype=np.int32),</span>
<span class="sd">            np.array([1, 1, 0], dtype=np.int32),</span>
<span class="sd">            np.array([ 0.4,  0.3,  0.8], dtype=np.float32),</span>
<span class="sd">            np.array([ 0.8,  0.5,  0.9], dtype=np.float32),</span>
<span class="sd">        )</span>

<span class="sd">    Example:</span>

<span class="sd">    assigns spatially constrained vsone match using results of nearest</span>
<span class="sd">    neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">dtype</span>
    <span class="c"># Find spatial errors of keypoints under current homography (kpts1 mapped into image2 space)</span>
    <span class="n">fx2_to_xyerr_sqrd</span> <span class="o">=</span> <span class="n">ktool</span><span class="o">.</span><span class="n">get_match_spatial_squared_error</span><span class="p">(</span><span class="n">kpts1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">fx2_to_fx1</span><span class="p">)</span>
    <span class="n">fx2_to_xyerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fx2_to_xyerr_sqrd</span><span class="p">)</span>
    <span class="n">fx2_to_xyerr_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">fx2_to_xyerr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">chip2_dlen_sqrd</span><span class="p">))</span>

    <span class="c"># Find matches and normalizers that satisfy spatial constraints</span>
    <span class="n">fx2_to_valid_match</span>      <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inbounds</span><span class="p">(</span><span class="n">fx2_to_xyerr_norm</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">match_xy_thresh</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">fx2_to_valid_normalizer</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">inbounds</span><span class="p">(</span><span class="n">fx2_to_xyerr_norm</span><span class="p">,</span> <span class="o">*</span><span class="n">norm_xy_bounds</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">vtool</span> <span class="kn">as</span> <span class="nn">vt</span>
    <span class="n">fx2_to_fx1_match_col</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">find_first_true_indices</span><span class="p">(</span><span class="n">fx2_to_valid_match</span><span class="p">)</span>
    <span class="n">fx2_to_fx1_norm_col</span>  <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">find_next_true_indices</span><span class="p">(</span><span class="n">fx2_to_valid_normalizer</span><span class="p">,</span> <span class="n">fx2_to_fx1_match_col</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">fx2_to_fx1_match_col</span> <span class="o">!=</span> <span class="n">fx2_to_fx1_norm_col</span><span class="p">,</span> <span class="s">&#39;normlizers are matches!&#39;</span>

    <span class="n">fx2_to_hasmatch</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">fx2_to_fx1_norm_col</span><span class="p">]</span>
    <span class="c"># IMAGE 2 Matching Features</span>
    <span class="n">fx2_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fx2_to_hasmatch</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">)</span>
    <span class="n">match_col_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">list_take</span><span class="p">(</span><span class="n">fx2_to_fx1_match_col</span><span class="p">,</span> <span class="n">fx2_match</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fx2_match</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">norm_col_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">list_take</span><span class="p">(</span><span class="n">fx2_to_fx1_norm_col</span><span class="p">,</span> <span class="n">fx2_match</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fx2_match</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c"># We now have 2d coordinates into fx2_to_fx1</span>
    <span class="c"># Covnert into 1d coordinates for flat indexing into fx2_to_fx1</span>
    <span class="n">_match_index_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">fx2_match</span><span class="p">,</span> <span class="n">match_col_list</span><span class="p">))</span>
    <span class="n">_norm_index_2d</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">fx2_match</span><span class="p">,</span> <span class="n">norm_col_list</span><span class="p">))</span>
    <span class="n">_shape2d</span>        <span class="o">=</span> <span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">match_index_1d</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">_match_index_2d</span><span class="p">,</span> <span class="n">_shape2d</span><span class="p">)</span>
    <span class="n">norm_index_1d</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">_norm_index_2d</span><span class="p">,</span> <span class="n">_shape2d</span><span class="p">)</span>

    <span class="c"># Find initial matches</span>
    <span class="c"># IMAGE 1 Matching Features</span>
    <span class="n">fx1_match</span> <span class="o">=</span> <span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">match_index_1d</span><span class="p">)</span>
    <span class="n">fx1_norm</span>  <span class="o">=</span> <span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">norm_index_1d</span><span class="p">)</span>
    <span class="c"># compute constrained ratio score</span>
    <span class="n">match_dist</span> <span class="o">=</span> <span class="n">fx2_to_dist</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">match_index_1d</span><span class="p">)</span>
    <span class="n">norm_dist</span>  <span class="o">=</span> <span class="n">fx2_to_dist</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">norm_index_1d</span><span class="p">)</span>

    <span class="c"># package and return</span>
    <span class="n">assigntup</span> <span class="o">=</span> <span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span>
    <span class="k">return</span> <span class="n">assigntup</span>

</div>
<div class="viewcode-block" id="assign_unconstrained_matches"><a class="viewcode-back" href="../../vtool.html#vtool.matching.assign_unconstrained_matches">[docs]</a><span class="k">def</span> <span class="nf">assign_unconstrained_matches</span><span class="p">(</span><span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    assigns vsone matches using results of nearest neighbors.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from vtool.matching import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; fx2_to_fx1 = np.array([[ 77,   971],</span>
<span class="sd">        &gt;&gt;&gt;                        [116,   120],</span>
<span class="sd">        &gt;&gt;&gt;                        [122,   128],</span>
<span class="sd">        &gt;&gt;&gt;                        [1075,  692],</span>
<span class="sd">        &gt;&gt;&gt;                        [ 530,   45],</span>
<span class="sd">        &gt;&gt;&gt;                        [  45,  530]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; fx2_to_dist = np.array([[ 0.05907059,  0.2389698 ],</span>
<span class="sd">        &gt;&gt;&gt;                         [ 0.02129555,  0.24083519],</span>
<span class="sd">        &gt;&gt;&gt;                         [ 0.03901863,  0.24756241],</span>
<span class="sd">        &gt;&gt;&gt;                         [ 0.14974403,  0.15112305],</span>
<span class="sd">        &gt;&gt;&gt;                         [ 0.22693443,  0.24428177],</span>
<span class="sd">        &gt;&gt;&gt;                         [ 0.2155838 ,  0.23641014]], dtype=np.float64)</span>
<span class="sd">        &gt;&gt;&gt; assigntup = assign_unconstrained_matches(fx2_to_fx1, fx2_to_dist)</span>
<span class="sd">        &gt;&gt;&gt; fx2_match, fx1_match, fx1_norm, match_dist, norm_dist = assigntup</span>
<span class="sd">        &gt;&gt;&gt; result = ut.list_str(assigntup, precision=3)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (</span>
<span class="sd">            np.array([0, 1, 2, 3, 4, 5], dtype=np.int32),</span>
<span class="sd">            np.array([  77,  116,  122, 1075,  530,   45], dtype=np.int32),</span>
<span class="sd">            np.array([971, 120, 128, 692,  45, 530], dtype=np.int32),</span>
<span class="sd">            np.array([ 0.059,  0.021,  0.039,  0.15 ,  0.227,  0.216], dtype=np.float64),</span>
<span class="sd">            np.array([ 0.239,  0.241,  0.248,  0.151,  0.244,  0.236], dtype=np.float64),</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fx2_match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fx2_to_fx1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">fx1_match</span> <span class="o">=</span> <span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fx1_norm</span>  <span class="o">=</span> <span class="n">fx2_to_fx1</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">match_dist</span> <span class="o">=</span> <span class="n">fx2_to_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">norm_dist</span>  <span class="o">=</span> <span class="n">fx2_to_dist</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">assigntup</span> <span class="o">=</span> <span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span>
    <span class="k">return</span> <span class="n">assigntup</span>

</div>
<div class="viewcode-block" id="unconstrained_ratio_match"><a class="viewcode-back" href="../../vtool.html#vtool.matching.unconstrained_ratio_match">[docs]</a><span class="k">def</span> <span class="nf">unconstrained_ratio_match</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">unc_ratio_thresh</span><span class="o">=.</span><span class="mi">625</span><span class="p">,</span>
                              <span class="n">fm_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">fs_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Lowes ratio matching</span>

<span class="sd">    fs_dtype = kwargs.get(&#39;fs_dtype&#39;, np.float32)</span>
<span class="sd">    fm_dtype = kwargs.get(&#39;fm_dtype&#39;, np.int32)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span> <span class="o">=</span> <span class="n">normalized_nearest_neighbors</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>
    <span class="c">#ut.embed()</span>
    <span class="n">assigntup</span> <span class="o">=</span> <span class="n">assign_unconstrained_matches</span><span class="p">(</span><span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span><span class="p">)</span>
    <span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span> <span class="o">=</span> <span class="n">assigntup</span>
    <span class="n">ratio_tup</span> <span class="o">=</span> <span class="n">ratio_test</span><span class="p">(</span><span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span>
                           <span class="n">norm_dist</span><span class="p">,</span> <span class="n">unc_ratio_thresh</span><span class="p">,</span> <span class="n">fm_dtype</span><span class="o">=</span><span class="n">fm_dtype</span><span class="p">,</span>
                           <span class="n">fs_dtype</span><span class="o">=</span><span class="n">fs_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ratio_tup</span>

</div>
<span class="nd">@profile</span>
<div class="viewcode-block" id="spatially_constrained_ratio_match"><a class="viewcode-back" href="../../vtool.html#vtool.matching.spatially_constrained_ratio_match">[docs]</a><span class="k">def</span> <span class="nf">spatially_constrained_ratio_match</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">kpts1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">chip2_dlen_sqrd</span><span class="p">,</span>
                                      <span class="n">match_xy_thresh</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scr_ratio_thresh</span><span class="o">=.</span><span class="mi">625</span><span class="p">,</span> <span class="n">scr_K</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                                      <span class="n">norm_xy_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                                      <span class="n">fm_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">fs_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    performs nearest neighbors, then assigns based on spatial constraints, the</span>
<span class="sd">    last step performs a ratio test.</span>

<span class="sd">    H - a homography H that maps image1 space into image2 space</span>
<span class="sd">    H should map from query to database chip (1 to 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="c"># Find several of image2&#39;s features nearest matches in image1</span>
    <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span> <span class="o">=</span> <span class="n">normalized_nearest_neighbors</span><span class="p">(</span><span class="n">flann</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">,</span> <span class="n">scr_K</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>
    <span class="c"># Then find those which satisfify the constraints</span>
    <span class="n">assigntup</span> <span class="o">=</span> <span class="n">assign_spatially_constrained_matches</span><span class="p">(</span>
        <span class="n">chip2_dlen_sqrd</span><span class="p">,</span> <span class="n">kpts1</span><span class="p">,</span> <span class="n">kpts2</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">fx2_to_fx1</span><span class="p">,</span> <span class="n">fx2_to_dist</span><span class="p">,</span>
        <span class="n">match_xy_thresh</span><span class="p">,</span> <span class="n">norm_xy_bounds</span><span class="o">=</span><span class="n">norm_xy_bounds</span><span class="p">)</span>
    <span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span> <span class="o">=</span> <span class="n">assigntup</span>
    <span class="c"># filter assignments via the ratio test</span>
    <span class="n">scr_tup</span> <span class="o">=</span> <span class="n">ratio_test</span><span class="p">(</span><span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span>
                         <span class="n">norm_dist</span><span class="p">,</span> <span class="n">scr_ratio_thresh</span><span class="p">,</span> <span class="n">fm_dtype</span><span class="o">=</span><span class="n">fm_dtype</span><span class="p">,</span>
                         <span class="n">fs_dtype</span><span class="o">=</span><span class="n">fs_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scr_tup</span>

</div>
<div class="viewcode-block" id="ratio_test"><a class="viewcode-back" href="../../vtool.html#vtool.matching.ratio_test">[docs]</a><span class="k">def</span> <span class="nf">ratio_test</span><span class="p">(</span><span class="n">fx2_match</span><span class="p">,</span> <span class="n">fx1_match</span><span class="p">,</span> <span class="n">fx1_norm</span><span class="p">,</span> <span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span><span class="p">,</span>
               <span class="n">ratio_thresh</span><span class="o">=.</span><span class="mi">625</span><span class="p">,</span> <span class="n">fm_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">fs_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Lowes ratio test for one-vs-one feature matches.</span>

<span class="sd">    Assumes reverse matches (image2 to image1) and returns (image1 to image2)</span>
<span class="sd">    matches. Generalized to accept any match or normalizer not just K=1 and K=2.</span>

<span class="sd">    Args:</span>
<span class="sd">        fx2_to_fx1 (ndarray): nearest neighbor indices (from flann)</span>
<span class="sd">        fx2_to_dist (ndarray): nearest neighbor distances (from flann)</span>
<span class="sd">        ratio_thresh (float):</span>
<span class="sd">        match_col (int or ndarray): column of matching indices</span>
<span class="sd">        norm_col (int or ndarray): column of normalizng indices</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (fm_RAT, fs_RAT, fm_norm_RAT)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m vtool.matching --test-ratio_test</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from vtool.matching import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; fx2_match  = np.array([0, 1, 2, 3, 4, 5], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; fx1_match  = np.array([77, 116, 122, 1075, 530, 45], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; fx1_norm   = np.array([971, 120, 128, 692, 45, 530], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; match_dist = np.array([ 0.059, 0.021, 0.039, 0.15 , 0.227, 0.216])</span>
<span class="sd">        &gt;&gt;&gt; norm_dist  = np.array([ 0.239, 0.241, 0.248, 0.151, 0.244, 0.236])</span>
<span class="sd">        &gt;&gt;&gt; ratio_thresh = .625</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; ratio_tup = ratio_test(fx2_match, fx1_match, fx1_norm, match_dist, norm_dist, ratio_thresh)</span>
<span class="sd">        &gt;&gt;&gt; (fm_RAT, fs_RAT, fm_norm_RAT) = ratio_tup</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = ut.list_str(ratio_tup, precision=3)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (</span>
<span class="sd">            np.array([[ 77,   0],</span>
<span class="sd">                      [116,   1],</span>
<span class="sd">                      [122,   2]], dtype=np.int32),</span>
<span class="sd">            np.array([ 0.753,  0.913,  0.843], dtype=np.float32),</span>
<span class="sd">            np.array([[971,   0],</span>
<span class="sd">                      [120,   1],</span>
<span class="sd">                      [128,   2]], dtype=np.int32),</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fx2_to_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">match_dist</span><span class="p">,</span> <span class="n">norm_dist</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">fs_dtype</span><span class="p">)</span>
    <span class="n">fx2_to_isvalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">fx2_to_ratio</span><span class="p">,</span> <span class="n">ratio_thresh</span><span class="p">)</span>
    <span class="n">fx2_match_RAT</span> <span class="o">=</span> <span class="n">fx2_match</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">fx2_to_isvalid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">fm_dtype</span><span class="p">)</span>
    <span class="n">fx1_match_RAT</span> <span class="o">=</span> <span class="n">fx1_match</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">fx2_to_isvalid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">fm_dtype</span><span class="p">)</span>
    <span class="n">fx1_norm_RAT</span> <span class="o">=</span> <span class="n">fx1_norm</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">fx2_to_isvalid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">fm_dtype</span><span class="p">)</span>
    <span class="c"># Turn the ratio into a score</span>
    <span class="n">fs_RAT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">fx2_to_ratio</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">fx2_to_isvalid</span><span class="p">))</span>
    <span class="n">fm_RAT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">fx1_match_RAT</span><span class="p">,</span> <span class="n">fx2_match_RAT</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="c"># return normalizer info as well</span>
    <span class="n">fm_norm_RAT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">fx1_norm_RAT</span><span class="p">,</span> <span class="n">fx2_match_RAT</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ratio_tup</span> <span class="o">=</span> <span class="n">fm_RAT</span><span class="p">,</span> <span class="n">fs_RAT</span><span class="p">,</span> <span class="n">fm_norm_RAT</span>
    <span class="k">return</span> <span class="n">ratio_tup</span>

</div>
<div class="viewcode-block" id="ensure_fsv_list"><a class="viewcode-back" href="../../vtool.html#vtool.matching.ensure_fsv_list">[docs]</a><span class="k">def</span> <span class="nf">ensure_fsv_list</span><span class="p">(</span><span class="n">fsv_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; ensure fs is at least Nx1 &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">fsv</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fsv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">fsv</span>
            <span class="k">for</span> <span class="n">fsv</span> <span class="ow">in</span> <span class="n">fsv_list</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="marge_matches"><a class="viewcode-back" href="../../vtool.html#vtool.matching.marge_matches">[docs]</a><span class="k">def</span> <span class="nf">marge_matches</span><span class="p">(</span><span class="n">fm_A</span><span class="p">,</span> <span class="n">fm_B</span><span class="p">,</span> <span class="n">fsv_A</span><span class="p">,</span> <span class="n">fsv_B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; combines feature matches from two matching algorithms</span>

<span class="sd">    Args:</span>
<span class="sd">        fm_A (ndarray[ndims=2]): type A feature matches</span>
<span class="sd">        fm_B (ndarray[ndims=2]): type B feature matches</span>
<span class="sd">        fsv_A (ndarray[ndims=2]): type A feature scores</span>
<span class="sd">        fsv_B (ndarray[ndims=2]): type B feature scores</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (fm_both, fs_both)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m vtool.matching --test-marge_matches</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from vtool.matching import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; fm_A  = np.array([[ 15, 17], [ 54, 29], [ 95, 111], [ 25, 125], [ 97, 125]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; fm_B  = np.array([[ 11, 21], [ 15, 17], [ 25, 125], [ 30,  32]], dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; fsv_A = np.array([[ .1, .2], [1.0, .9], [.8,  .2],  [.1, .1], [1.0, .9]], dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; fsv_B = np.array([[.12], [.3], [.5], [.7]], dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; (fm_both, fs_both) = marge_matches(fm_A, fm_B, fsv_A, fsv_B)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = ut.list_str((fm_both, fs_both), precision=3)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (</span>
<span class="sd">            np.array([[ 15,  17],</span>
<span class="sd">                      [ 25, 125],</span>
<span class="sd">                      [ 54,  29],</span>
<span class="sd">                      [ 95, 111],</span>
<span class="sd">                      [ 97, 125],</span>
<span class="sd">                      [ 11,  21],</span>
<span class="sd">                      [ 30,  32]], dtype=np.int32),</span>
<span class="sd">            np.array([[ 0.1 ,  0.2 ,  0.3 ],</span>
<span class="sd">                      [ 0.1 ,  0.1 ,  0.5 ],</span>
<span class="sd">                      [ 1.  ,  0.9 ,   nan],</span>
<span class="sd">                      [ 0.8 ,  0.2 ,   nan],</span>
<span class="sd">                      [ 1.  ,  0.9 ,   nan],</span>
<span class="sd">                      [  nan,   nan,  0.12],</span>
<span class="sd">                      [  nan,   nan,  0.7 ]], dtype=np.float64),</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Flag rows found in both fmA and fmB</span>
    <span class="c"># that are intersecting (both) or unique (only)</span>
    <span class="kn">import</span> <span class="nn">vtool</span> <span class="kn">as</span> <span class="nn">vt</span>
    <span class="n">flags_both_A</span><span class="p">,</span> <span class="n">flags_both_B</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">intersect2d_flags</span><span class="p">(</span><span class="n">fm_A</span><span class="p">,</span> <span class="n">fm_B</span><span class="p">)</span>
    <span class="n">flags_only_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flags_both_A</span><span class="p">)</span>
    <span class="n">flags_only_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flags_both_B</span><span class="p">)</span>
    <span class="c"># independent matches</span>
    <span class="n">fm_both_AB</span>  <span class="o">=</span> <span class="n">fm_A</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_both_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fm_only_A</span>   <span class="o">=</span> <span class="n">fm_A</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_only_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fm_only_B</span>   <span class="o">=</span> <span class="n">fm_B</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_only_B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># independent scores</span>
    <span class="n">fsv_both_A</span> <span class="o">=</span> <span class="n">fsv_A</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_both_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fsv_both_B</span> <span class="o">=</span> <span class="n">fsv_B</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_both_B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fsv_only_A</span> <span class="o">=</span> <span class="n">fsv_A</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_only_A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">fsv_only_B</span> <span class="o">=</span> <span class="n">fsv_B</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">flags_only_B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># build merge offsets</span>
    <span class="n">offset1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_both_AB</span><span class="p">)</span>
    <span class="n">offset2</span> <span class="o">=</span> <span class="n">offset1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_only_A</span><span class="p">)</span>
    <span class="n">offset3</span> <span class="o">=</span> <span class="n">offset2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">fm_only_B</span><span class="p">)</span>
    <span class="c"># Merge feature matches</span>
    <span class="n">fm_merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">fm_both_AB</span><span class="p">,</span> <span class="n">fm_only_A</span><span class="p">,</span> <span class="n">fm_only_B</span><span class="p">])</span>
    <span class="c"># Merge feature scores</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="n">fm_merged</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">num_cols_A</span> <span class="o">=</span> <span class="n">fsv_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_cols_B</span> <span class="o">=</span> <span class="n">fsv_B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_cols</span> <span class="o">=</span> <span class="n">num_cols_A</span> <span class="o">+</span> <span class="n">num_cols_B</span>
    <span class="n">fsv_merged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">fsv_merged</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">offset1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">num_cols_A</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsv_both_A</span>
    <span class="n">fsv_merged</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">offset1</span><span class="p">,</span> <span class="n">num_cols_A</span><span class="p">:]</span>  <span class="o">=</span> <span class="n">fsv_both_B</span>
    <span class="n">fsv_merged</span><span class="p">[</span><span class="n">offset1</span><span class="p">:</span><span class="n">offset2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">num_cols_A</span><span class="p">]</span> <span class="o">=</span> <span class="n">fsv_only_A</span>
    <span class="n">fsv_merged</span><span class="p">[</span><span class="n">offset2</span><span class="p">:</span><span class="n">offset3</span><span class="p">,</span> <span class="n">num_cols_A</span><span class="p">:]</span>  <span class="o">=</span> <span class="n">fsv_only_B</span>
    <span class="k">return</span> <span class="n">fm_merged</span><span class="p">,</span> <span class="n">fsv_merged</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m vtool.matching</span>
<span class="sd">        python -m vtool.matching --allexamples</span>
<span class="sd">        python -m vtool.matching --allexamples --noface --nosrc</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="kn">as</span> <span class="nn">ut</span>  <span class="c"># NOQA</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Jon Crall.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.1.dev1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>